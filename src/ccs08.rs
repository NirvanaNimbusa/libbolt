/*
Implementation of the ZK Range Proof scheme, based on:
Efficient Protocols for Set Membership and Range Proofs
Jan Camenisch, Rafik Chaabouni, and abhi shelat
Asiacrypt 2008
*/
extern crate pairing;
extern crate rand;

use super::*;
use cl::{KeyPair, Signature, PublicParams, setup};
use ped92::{CSPublicKey, Commitment};
use pairing::{Engine, CurveProjective};
use ff::PrimeField;
use std::collections::HashMap;
use std::fmt::Display;

/*
paramsUL contains elements generated by the verifier, which are necessary for the prover.
This must be computed in a trusted setup.
*/
#[derive(Clone)]
struct ParamsUL<E: Engine> {
    pub mpk: PublicParams<E>,
    pub signatures: HashMap<String, Signature<E>>,
    pub com: CSPublicKey<E>,
    kp: KeyPair<E>,
    // u determines the amount of signatures we need in the public params.
    // Each signature can be compressed to just 1 field element of 256 bits.
    // Then the parameters have minimum size equal to 256*u bits.
    u: i64,
    // l determines how many pairings we need to compute, then in order to improve
    // verifier`s performance we want to minize it.
    // Namely, we have 2*l pairings for the prover and 3*l for the verifier.
    l: i64,
}

/*
proofUL contains the necessary elements for the ZK range proof.
*/
#[derive(Clone)]
struct ProofUL<E: Engine> {
    v: Vec<E::G1>,
    d: E::G2,
    comm: Commitment<E>,
    a: Vec<E::Fqk>,
    s: Vec<E::Fr>,
    t: Vec<E::Fr>,
    zsig: Vec<E::Fr>,
    zv: Vec<E::Fr>,
    ch: E::Fr,
    m: E::Fr,
    zr: E::Fr,
}

#[derive(Clone)]
pub struct RangeProof<E: Engine> {
    p1: ProofUL<E>,
    p2: ProofUL<E>,
}
/*
params contains elements generated by the verifier, which are necessary for the prover.
This must be computed in a trusted setup.
*/
#[derive(Clone)]
pub struct RPPublicParams<E: Engine> {
    p: ParamsUL<E>,
    a: i64,
    b: i64,
}

/*
setup_ul generates the signature for the interval [0,u^l).
The value of u should be roughly b/log(b), but we can choose smaller values in
order to get smaller parameters, at the cost of having worse performance.
*/
fn setup_ul<E: Engine>(u: i64, l: i64) -> ParamsUL<E> {
    let mut rng = &mut rand::thread_rng();

    let mpk = setup(&mut rng);
    let kp = KeyPair::<E>::generate(&mut rng, &mpk, 1);

    let mut signatures: HashMap<String, Signature<E>> = HashMap::new();
    for i in 0..u {
        let sig_i = kp.sign(&mut rng, &vec! {E::Fr::from_str(i.to_string().as_str()).unwrap()});
        signatures.insert(i.to_string(), sig_i);
    }

    let com = CSPublicKey::setup(rng);
    return ParamsUL { mpk, signatures, com, kp, u, l };
}

/*
Decompose receives as input an integer x and outputs an array of integers such that
x = sum(xi.u^i), i.e. it returns the decomposition of x into base u.
*/
fn decompose(x: i64, u: i64) -> Vec<i64> {
    let l = (x as f64).log(u as f64).ceil() as usize;
    let mut result = Vec::with_capacity(l as usize);
    let mut decomposer = x.clone();
    for i in 0..l {
        result.push(decomposer % u);
        decomposer = decomposer / u;
    }
    return result;
}

/*
prove_ul method is used to produce the ZKRP proof that secret x belongs to the interval [0,U^L].
*/
fn prove_ul<E: Engine>(x: i64, r: E::Fr, p: ParamsUL<E>) -> ProofUL<E> {
    let mut rng = &mut rand::thread_rng();
    let mut mutr = r.clone();

    let decx = decompose(x, p.u);
    let modx = E::Fr::from_str(&(x.to_string())).unwrap();

// Initialize variables
    let mut v = Vec::<E::Fr>::with_capacity(p.l as usize);
    let mut V = Vec::<E::G1>::with_capacity(p.l as usize);
    let mut a = Vec::<E::Fqk>::with_capacity(p.l as usize);
    let mut s = Vec::<E::Fr>::with_capacity(p.l as usize);
    let mut t = Vec::<E::Fr>::with_capacity(p.l as usize);
    let mut zsig = Vec::<E::Fr>::with_capacity(p.l as usize);
    let mut zv = Vec::<E::Fr>::with_capacity(p.l as usize);
    let mut one = E::G2::one();
    let mut D = E::G2::zero();
    one.negate();
    D.add_assign(&one);
    let mut m = E::Fr::rand(rng);

// D = H^m
    let mut Dnew = p.com.h;
    Dnew.mul_assign(m);
    for i in 0..p.l as usize {
        v.push(E::Fr::rand(rng));
        let mut A = p.signatures.get(&decx[i].to_string()).unwrap().H;
        A.mul_assign(v[i]);
        V.push(A);
        s.push(E::Fr::rand(rng));
        t.push(E::Fr::rand(rng));
        a.push(E::pairing( V[i], p.mpk.g2));
        a[i].pow(s[i].into_repr());
        a[i] = a[i].inverse().unwrap();
        let mut E = E::pairing(p.mpk.g1, p.mpk.g2);
        E.pow(t[i].into_repr());
        a[i].add_assign(&E);

        let ui = p.u.pow(i as u32);
        let mut muisi = s[i].clone();
        muisi.mul_assign(&E::Fr::from_str(&ui.to_string()).unwrap());
        let mut aux = p.mpk.g2.clone();
        aux.mul_assign(muisi);
        D.add_assign(&aux);
    }
    D.add_assign(&Dnew);

    let C = p.com.commit(rng, modx, Some(mutr));
// Fiat-Shamir heuristic
    let c = Hash::<E>(a.clone(), D.clone());

    let mut zr = m.clone();
    mutr.mul_assign(&c);
    zr.sub_assign(&mutr);
    for i in 0..p.l as usize {
        zsig[i] = s[i].clone();
        let mut dx = E::Fr::from_str(&decx[i].to_string()).unwrap();
        dx.mul_assign(&c);
        zsig[i].sub_assign(&dx);
        let mut vi = v[i].clone();
        vi.mul_assign(&c);
        let mut ti = t[i].clone();
        ti.sub_assign(&vi);
        zv[i] = ti.clone();
    }
    return ProofUL {v: V, d: D, comm: C, a, s, t, zsig, zv, ch: c, m, zr};
}

fn Hash<E: Engine>(a: Vec<E::Fqk>, D: E::G2) -> E::Fr {
    // create a Sha256 object
    let mut a_vec: Vec<u8> = Vec::new();
    for a_el in a {
        a_vec.extend(format!("{}", a_el).bytes());
    }

    let mut x_vec: Vec<u8> = Vec::new();
    x_vec.extend(format!("{}", D).bytes());
    a_vec.extend(x_vec);
    let sha2_digest = sha512::hash(a_vec.as_slice());

    let mut hash_buf: [u8; 64] = [0; 64];
    hash_buf.copy_from_slice(&sha2_digest[0..64]);
    return E::Fr::from_str(&str::from_utf8(&hash_buf).unwrap()).unwrap();
}


/*
Setup receives integers a and b, and configures the parameters for the rangeproof scheme.
*/
pub fn ccs08_setup<E: Engine>(a: i64, b: i64) -> RPPublicParams<E> {
    // Compute optimal values for u and l
    if a > b {
        panic!("a must be less than or equal to b");
    }
    let p: PublicParams<E>;
    let logb = (b as f64).log10();
    if logb != 0.0 {
        let u = b / logb as i64;
        if u != 0 {
            let l = (b as f64).log(u as f64).ceil() as i64;
            let params_out: ParamsUL<E> = setup_ul(u, l);
            return RPPublicParams { p: params_out, a, b };
        } else {
            panic!("u is zero");
        }
    } else {
        panic!("log(b) is zero");
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use pairing::bls12_381::{Bls12, Fr};

    #[test]
    fn setup_ul_works() {
        let mut rng = &mut rand::thread_rng();
        let params_set = setup_ul::<Bls12>(2, 3);
        assert_eq!(2, params_set.signatures.len());
        for (m, s) in params_set.signatures {
            assert_eq!(true, params_set.kp.verify(&params_set.mpk, &vec! {Fr::from_str(m.to_string().as_str()).unwrap()}, &s));
        }
    }

    #[test]
    fn decompose_works() {
        assert_eq!(vec! {1, 2, 2}, decompose(25, 3));
        assert_eq!(vec! {0, 6, 6}, decompose(336, 7));
        assert_eq!(vec! {5, 3, 4}, decompose(285, 8));
        assert_eq!(vec! {8, 9}, decompose(125, 13));
        assert_eq!(vec! {5, 2, 0, 3, 2, 0, 3}, decompose(143225, 6));
    }

    #[test]
    fn setup_works() {
        let mut rng = &mut rand::thread_rng();
        let public_params = ccs08_setup::<Bls12>(2, 10);
        assert_eq!(2, public_params.a);
        assert_eq!(10, public_params.b);
        assert_eq!(10, public_params.p.signatures.len());
        assert_eq!(10 / ((10 as f64).log10() as i64), public_params.p.u);
        assert_eq!(((10 / (10 / ((10 as f64).log10() as i64))) as f64).ceil() as i64, public_params.p.l);
        for (m, s) in public_params.p.signatures {
            assert_eq!(true, public_params.p.kp.verify(&public_params.p.mpk, &vec! {Fr::from_str(m.to_string().as_str()).unwrap()}, &s));
        }
    }

    #[test]
    #[should_panic(expected = "a must be less than or equal to b")]
    fn setup_wrong_a_and_b() {
        let mut rng = &mut rand::thread_rng();
        let public_params = ccs08_setup::<Bls12>(10, 2);
    }

    #[test]
    #[should_panic(expected = "u is zero")]
    fn setup_wrong_b() {
        let mut rng = &mut rand::thread_rng();
        let public_params = ccs08_setup::<Bls12>(-1, 0);
    }

    #[test]
    #[should_panic(expected = "log(b) is zero")]
    fn setup_wrong_logb() {
        let mut rng = &mut rand::thread_rng();
        let public_params = ccs08_setup::<Bls12>(-1, 1);
    }
}
